## 2021 Project 2

![](logo.png)

Ερωτήσεις:

1. Πού βρίσκεται ο Γιώργος;
1. Ποιος έκλεψε τα αρχεία του "Plan X";
1. Πού βρίσκονται τα αρχεία του "Plan X";
1. Ποια είναι τα results του "Plan Y";
1. Ποιο είναι το code του "Plan Z";




#### Παρατηρήσεις

- Οι ίδιες ομάδες με την εργασία 1
- Εγγραφή στο github: https://classroom.github.com/g/jlkOQHdH 
- Μόλις ολοκληρώσετε κάθε βήμα στέλνετε claim στο ys13@chatzi.org
- Για τα βήματα 3-5 απαιτείται να γράψετε ένα πρόγραμμα που να αυτοματοποιεί την εύρεση της λύσης.
  Μπορείτε να χρησιμοποιήσετε ό,τι γλώσσα προγραμματισμού θέλετε, αλλά θα πρέπει να μπορώ να το τρέξω
  σε Ubuntu 20.04 χρησιμοποιώντας software που είναι διαθέσιμο στο Ubuntu. Θα πρέπει επίσης
  να φτιάξετε ένα script `run.sh` που εκτελεί το πρόγραμμα με ό,τι παραμέτρους χρειάζονται.
- Επίσης γράφετε report στο README.md με τα βήματα που ακολουθήσατε, και το κάνετε commit μαζί με οποιοδήποτε κώδικα χρησιμοποιήσατε
- Βαθμολογία
    - Η δυσκολία στα βήματα αυξάνεται απότομα.
    - Για ό,τι δεν ολοκληρώσετε περιγράψτε (και υλοποιήστε στο πρόγραμμα) την πρόοδό σας και πώς θα μπορούσατε να συνεχίσετε.
    - Με τα πρώτα 2 βήματα παίρνετε 5 στο μάθημα (αν έχετε πάει καλά στην εργασία 1)
    - Με τα 3-5 φτάνετε μέχρι το 10 (δεν υπάρχει γραπτή εξέταση)
    - Για τους μεταπτυχιακούς τα 3-5 είναι προαιρετικά. ΔΕΝ αντικαθιστούν το project
     (αλλά μπορούν να λειτουργήσουν προσθετικά στο βαθμό της εργασίας 1)
    - Για τα βήματα 3-5 μπορεί να γίνει προφορική εξέταση
- Timeline
    - Την πρώτη εβδομάδα δεν υπάρχουν hints
    - 11/6: αρχίζουν τα hints για τα βήματα 1,2
    - 16/6: deadline για τα βήματα 1,2
    - Για τα βήματα 3-5 δίνονται hints μόνο σε όσους ζητήσουν (με μικρό penalty)
    - 11/7: deadline για τα βήματα 3-5
- Η ταχύτητα των λύσεων (και ο αριθμός hints που έχουν δοθεί) μετράει στο βαθμό
(ειδικά για τα βήματα 1,2)

- __Οχι spoilers__
- __Οχι DoS__ (ή μαζικά requests, δε χρειάζεται
κάτι τέτοιο)


--------------------------------------------------------------------------------------------------------------------------------------------
#### Μέλη ομάδας

- 1115201700175, Τσουράκης Ορφέας
- 1115201700164, Τίλε Ιορδάνης


#### Απαντήσεις

1) Πού βρίσκεται ο Γιώργος;

Αρχικά, όπως είναι προφανές χρησιμοποιήθηκε ο Tor Browser για την χρήση του onion link που δίνεται στην εικόνα. Aνοίγοντας το link επειδή δεν υπήρχε κάποια ιδιαίτερη αλληλεπίδραση με την σελίδα σκεφτήκαμε να ανοίξουμε τον source html κώδικα μήπως υπάρχει κάτι κρυφό που δεν φαίνεται και όντως υπήρχε ένα σχόλιο που περιείχε ένα link (*https://blog.0day.rocks/securing-a-web-hidden-service-89d935ba1c1d*) που περιέγραφε τις ενέργειες που ακολουθήθηκαν για να παραμείνει κρυφό το onion service από το δημόσιο δίκτυο. Έτσι, παρατηρήσαμε ότι δεν είχε τηρηθεί πλήρως ό,τι ανέφερε η παραπάνω σελίδα εφόσον επιτρεπόταν  η πρόσβαση στην σελίδα με τις πληροφορίες του server (*server-info*) και με αυτόν τον τρόπο παρατηρήσαμε αμέσως ότι υπήρχε και άλλος ένας virtual host στον ίδιο server με όνομα *flffeyo7q6zllfse2sgwh7i5b5apn73g6upedyihqvaarhq5wrkkn7ad* που είναι προφανές ότι παραπέμπει σε κάποιο άλλο onion link. Επισκέπτοντας, λοιπόν, το onion link αυτό και έπειτα βλέποντας ένα πεδίο που ζητάει κάποιο συνθηματικό οι πρώτες σκέψεις ήταν να πάρουμε πρόσβαση μέσω sql injection. Βέβαια, μετά από μάταιες προσπάθειες αποφασίσαμε να αλλάξουμε τακτική και να βρούμε κάποιο άλλο στοιχείο που πιθανώς να ήταν κρυφό και να έδινε κάποιο hint για την πρόσβαση. Όμως, από όλες τις διαθέσιμες σελίδες δεν μπορέσαμε να βρούμε κάτι χρήσιμο και αποφασίσαμε να αναζητήσουμε στο δημόσιο δίκτυο χρησιμοποιώντας (google, shodan) με την ελπίδα να ταιριάξουμε τις βασικές πληροφορίες του server (*server version*, *server built*, …) με κάποιον server που βρίσκεται online στο δημόσιο δίκτυο ώστε να βρούμε την IP. Δυστυχώς, διαπιστώθηκε τελικά ότι ο server “ακούει” στο *localhost* (*Listen 127.0.0.1:80*, *Listen 127.0.0.1:443* ) οπότε ήταν κρυμμένος από το δημόσιο δίκτυο. Έτσι, αποκλείοντας όλες τις διαθέσιμες επιλογές και παρατηρώντας για άλλη μια φορά προσεκτικά τα βασικά configurations του server αντιληφθήκαμε πως υπήρχε ένα regex που κάνει match με οποιοδήποτε αρχείο τελειώνει σε *.phps* και επιστρέφει τον source php κώδικα του (*application/x-httpd-php-source*). Αμέσως, αντικαταστήσαμε την κατάληξη *.php* σε *.phps* της *access.php* σελίδας που επέστρεφε μηνύματα λάθους στην περίπτωση λάθους συνθηματικού, μιας και ήταν η μοναδική *.php* σελίδα που δινόταν ξεκάθαρα και τελικά πήραμε τον source κώδικα ο οποίος έδινε όλες τις απαραίτητες πληροφορίες για να πάρουμε πρόσβαση σε ένα μυστικό. Η μια πληροφορία δινόταν στα σχόλια και είχε να κάνει με το όνομα χρήστη και ήταν ουσιαστικά ένας γρίφος του οποίου η λύση βρέθηκε στο *https://math.stackexchange.com/questions/3710141/how-to-find-the-48th-multiple-of-7-that-contains-a-7-in-its-decimal-representati/3710257* όπου η απάντηση ήταν ο αριθμός 1337 και εφόσον υπήρχε ένας έλεγχος που απαιτούσε το μέγεθος της εισόδου να είναι 7 προσθέσαμε 3 μηδενικά πριν τον αριθμό τα οποία τα αγνοεί και η συνάρτηση *intval* (θα μπορούσαμε να περάσουμε τον αριθμό και ως δεκαδικό βάζοντας υποδιαστολή δηλαδή με δυο μηδενικα δεξιά του αριθμού) με αποτέλεσμα να προσπεράσουμε τον έλεγχο αυτόν. Για να προσπεράσουμε τον κωδικό, εφόσον δεν γνωρίζαμε κάποιον κωδικό, η πρώτη σκέψη ήταν να κάνουμε την συνάρτηση *strcmp* να επιστρέψει 0 και ψάχνοντας το πως δουλεύει η συνάρτηση *strcmp* διαπιστώσαμε ότι για διαφορετικούς τύπους επιστρέφει *NULL* το οποίο είναι αρκετά χρήσιμο γιατί θα γινόταν typecast λόγω του *!=* και όχι του *!==* (*NULL* == 0 αλλά όχι *NULL* === 0). Άρα το μόνο που έμενε ήταν να περάσουμε τον κωδικό ως πίνακα στο url και τελικά με αυτόν τον τρόπο καταφέραμε να πάρουμε ένα μυστικό μονοπάτι με το τελικό query να μοιάζει κάπως έτσι *http://flffeyo7q6zllfse2sgwh7i5b5apn73g6upedyihqvaarhq5wrkkn7ad.onion/access.php?user=0001337&password[]=*. Στην συνέχεια, έχοντας το μυστικό αυτό μονοπάτι βρήκαμε ένα άλλο μυστικό onion link που αφορά το "Plan X" για τα επόμενα ερωτήματα και όσον αφορά τον Γιώργο ανακαλύψαμε ένα post που φανερώθηκε λόγω directory listing στο μονοπάτι *http://flffeyo7q6zllfse2sgwh7i5b5apn73g6upedyihqvaarhq5wrkkn7ad.onion/blogposts7589109238/blogposts* το οποίο φανέρωνε έναν τυχερό αριθμό επισκέπτη που αφορά την αρχική σελίδα. Αμέσως, σκεφτήκαμε ότι είχε να κάνει με τον αριθμό επισκέπτη 204 που έβγαζε πάντα μέσω του cookie που μας έδινε ο server. Πειραματιζόμενοι με το cookie τοποθετώντας κάποιες δικές μας εισόδους είδαμε κάποια μηνύματα λάθους όπως *bad base64…* και *bad sha256…* και εν συντομία καταλήξαμε στο γεγονός ότι το cookie είχε την μορφη *base64(num : sha256(num))* όπου *num* οποιοσδήποτε αριθμός και στην δική μας περίπτωση ο αριθμός του τυχερού επισκέπτη. Ύστερα, αφότου φανερώθηκε ένα μυστικό μονοπάτι στην αρχική σελίδα των *ys13 fixers* βρήκαμε δύο αρχεία με κατάληξη *.gpg* και κάποια notes που εξηγούσαν πως κωδικοποιήθηκαν τα αρχεία αυτά ενώ ταυτόχρονα δινόταν και ένας κωδικός μιας συναλλαγής στο Ethereum που φυσικά θα είχε σχέση με το ίδιο το κλειδί. Επισκέπτοντας τo *https://ropsten.etherscan.io/* και αναζητώντας την συναλλαγή παρατηρήσαμε ότι στο πεδίο *input data* υπήρχε κάποιο συνθηματικό που λεγόταν *bigtent* και κατευθείαν η πρώτη σκέψη ήταν να δημιουργήσουμε ένα κλειδί με την ημερομηνία της συναλλαγής και το συνθηματικό αυτό. Δυστυχώς, αυτό δεν δούλεψε οπότε σκεφτήκαμε να ψάξουμε πάλι στο Ethereum και να βρούμε στοιχεία σχετικά με τον αποστολέα και τον παραλήπτη και τις συναλλαγές τους αλλά και πάλι δεν βρήκαμε κάτι το ιδιαίτερο. Μια απο τις πιθανές επιλογές ήταν να δοκιμάσουμε και άλλες ημερομηνίες εφόσον είχαμε κάποιο μυστικό οπότε δοκιμάσαμε να κάνουμε brute force όλες τις πιθανές ημερομηνίες αρχίζοντας από την φετινή χρονιά (2021) και πηγαίνοντας προς τις προηγούμενες. Έτσι, γράψαμε ένα python script *sha256brute.py* γι αυτήν την δουλεία και για καλή μας τύχη πετύχαμε γρήγορα την ημερομηνία αποκρυπτογραφώντας τελικά τα αρχεία. Στην συνέχεια, μέσα στο *signal.log* βρήκαμε ένα *sha1 hash* ενός *git* commit και μια ιδέα ήταν να ψάξουμε στο github για το commit αυτό αλλά δεν βρέθηκε κάτι. Από την άλλη είχαμε και το *firefox.log* που είχε εκατομμύρια ίδιες εγγραφές με το ίδιο link (*https://en.wikipedia.org/wiki/The_Conversation*). Προβληματισμένοι με το τεράστιο μέγεθος αυτό σκεφτήκαμε να αναζητήσουμε με βάση κάποιο regex, μιας και ανοίξαμε αρχείο στο *VScode*, που κάνει match κάτι διαφορετικό από το παραπάνω link. Συνεχίζοντας εμπνευσμένοι από το *https://superuser.com/questions/1279062/regex-matching-line-not-containing-the-string* δοκιμάσαμε το regex *^((?!https:\\/\\/en\\.wikipedia\\.org\\/wiki\\/The_Conversation).)\*$* και βρήκαμε μια μοναδική εγγραφή με κάποιο link σε ένα github repository (*https://github.com/asn-d6/tor*), πράγμα αρκετά λογικό αφού δινόταν το hash του commit το οποίο το χρησιμοποιήσαμε για να δούμε τα περιεχόμενα του. Το τελευταίο πράγμα, λοιπόν, που έμενε ήταν ένας “γρίφος” που πολύ εύκολα κάποιος μπορεί να καταλάβει ότι είχε να κάνει με ασύμμετρη κρυπτογραφία *RSA* με βάση τα δοθέντα στοιχεία. Η πρώτη σκέψη ήταν να χρησιμοποιήσουμε το δημόσιο κλειδί (*e* και *N*) ώστε να αποκρυπτογραφήσουμε τα μηνύματα με την διαίσθηση ότι τα μηνύματα κρυπτογραφήθηκαν με το ιδιωτικό κλειδί δηλαδή κάτι σαν υπογραφή. Εκεί προέκυψαν και κάποια άλλα προβλήματα που είχαν να κάνουν με overflow αλλά επιλύθηκαν με την τεχνική του *modular exponentiation* ((a ⋅ b) mod m = [(a mod m) ⋅ (b mod m)] mod m). Έχοντας καταφέρει να βρούμε το *x* και το *y* παρατηρήσαμε ότι τελικά το link δεν ήταν σωστό και υποψιαστήκαμε πως μπορεί το κάθε μήνυμα να έχει κρυπτογραφηθεί με το δημόσιο κλειδί (*e* και *N*) οπότε σε αυτή την περίπτωση θα έπρεπε να να βρούμε το *d* δηλαδή το ιδιωτικό κλειδί (*d* και *N*) για την αποκρυπτογράφηση. Διαπιστώνοντας, ότι το *N* δεν ήταν αρκετά μεγάλο γράψαμε ένα άλλο python script *rsacrack.py* το οποίο εξέταζε με αποτελεσματικό brute force τρόπο να βρεί κάποιον διαιρέτη (μετά ήταν εύκολο να βρεθεί και ο άλλος). Τελικά, υπολογίσαμε το *Φ* του Euler, βρήκαμε έπειτα το *d* από την σχέση *d = e^(-1) mod Φ(n)*  και χρησιμοποιήσαμε *modular exponentiation* με αυτό το *d* για την αποκρυπτογράφηση των μηνυμάτων με αποτέλεσμα το link να είναι σωστό και να βρεθεί η τοποθεσία του Γιώργου.

2) Ποιος έκλεψε τα αρχεία του "Plan X";

Αφού λοιπόν βρέθηκε ο Γιώργος, το επόμενο βήμα ήταν να ασχοληθούμε με το "Plan X" όπου τα μόνα στοιχεία που είχαμε για αυτό υπήρχαν στο *http://flffeyo7q6zllfse2sgwh7i5b5apn73g6upedyihqvaarhq5wrkkn7ad.onion/blogposts7589109238/blogposts/diary2.html*. Το πρώτο στοιχείο ήταν ένα repository στο github το οποίο είχε να κάνει με έναν open-source server γραμμένο σε C (*github:chatziko/pico*) και το άλλο στοιχείο ήταν ένα νέο onion link (*zwt6vcp6d5tao7tbe3je6a2q4pwdfqli62ekuhjo55c7pqlet3brutqd.onion*) το οποίο οδηγούσε σε έναν τέτοιον server που είχε να κάνει με το "Plan X". Κατά την επίσκεψη στην σελίδα αυτή εμφανιζόταν πάντα μια φόρμα για login πράγμα λογικό εφόσον είχε σεταριστεί το αντίστοιχο header για authorization. Μη γνωρίζοντας λοιπόν κάποιο όνομα χρήστη και κωδικό σκεφτήκαμε πως κάπως πρέπει να εισβάλλουμε οπότε η προσοχή μας επικεντρώθηκε στον source κώδικα του *pico* και συγκεκριμένα στην συνάρτηση *check_auth* που έκανε αυτόν τον έλεγχο αλλά δεν βρήκαμε κάποιον τρόπο να “ξεγελάσουμε” το authorization. Παράλληλα, σετάραμε τον παραπάνω server τοπικά για να μπορέσουμε να τον τρέξουμε κάνοντας debugging. Όμως, σε αυτό το σημείο παρατηρήσαμε ένα αρκετά χρήσιμο warning κατά το compilation το οποίο εντάσσεται στην κατηγορία *-Wformat-security* όπου είχε να κάνει με μια κλήση της *printf* η οποία πρώτον δεν είχε παραμέτρους και δεύτερον και σημαντικότερο το format string εξαρτώταν από την είσοδο στο όνομα χρήστη κατά το login. Έτσι, η πρώτη ιδέα ήταν να περάσουμε ως όνομα χρήστη κάποιο αναγνωριστικό στο format αυτό string (%d, %x, …) όπου είδαμε ότι πράγματι δούλεψε εφόσον επιστρέφονταν στο *WWW-Authenticate* header κάποιοι μυστήριοι αριθμοί-διευθύνσεις. Ψάχνοντας ταυτόχρονα στο internet βρήκαμε ότι αυτή η ευπάθεια εντασσόταν σε μια αρκετά γνωστή κατηγορία (*Format String Vulnerability*) και είδαμε το πως μπορούμε να την εκμεταλλευτούμε για να τυπώσουμε τα περιεχόμενα της στοίβας! Πιο συγκεκριμένα, για κάθε αναγνωριστικό του format string η *printf* το αντιστοιχεί με κάποιο όρισμα (των 4 bytes) στην στοίβα από το τέλος οπότε με αυτόν τον τρόπο κάνουμε την *printf* να πιστεύει ότι έχει έναν αριθμό ορισμάτων που ελέγχεται από εμάς (το οποίο είναι αρκετά χρήσιμο γιατί τα τυπώνει). Παρατηρώντας, στην συνέχεια, ότι στην συνάρτηση *check_auth* στην οποία βρισκόταν η *printf* βρισκόταν και ένας δείκτης στην αρχή ενός δισδιάστατου στατικού πίνακα 100 συμβολοσειρών των 100 χαρακτήρων (πράγμα αρκετά καλό αφού ο δείκτης ταυτίζεται με δείκτη στην πρώτη συμβολοσειρά) που περιείχε τα πραγματικά στοιχεία των χρηστών ο σκοπός μας ήταν να βρούμε αυτόν τον δείκτη στην στοίβα. Επηρεασμένοι από το *https://www.geeksforgeeks.org/format-string-vulnerability-and-prevention-with-example/*, η πρώτη ιδέα ήταν να γράψουμε το python script *format_string_brute.py* ώστε γίνει αυτή διαδικασία αυτοματοποιημένα δηλαδή σκανάροντας όλη την στοίβα περνώντας κάθε φορά ως όνομα χρήστη το *%i$s* με το i να αρχίζει από το 1 και να αυξάνεται (ισοδύναμο με το να γράφαμε i-1 φορές πίσω από το %s κάποιο %p ή %x που δεν θα προκαλούσε κάποιο segmentation fault) με αποτέλεσμα να βρούμε την εγγραφή *admin:e5614e27f3c21283ad532a1d23b9e29d* 4 φορές (για i = 7 , i = 32, i = 88, i = 105). Ένας εναλλακτικός και πιο άμεσος τρόπος για την εύρεση του δείκτη ήταν μέσα από debug όπου μπορεί να παρατηρήσει κανείς ότι δείκτης αντιγράφεται 92 bytes κάτω από τον *$ebp* ενώ πριν κληθεί η *printf* ο *$esp* βρίσκεται 120 bytes κάτω από τον *$ebp* οπότε δεδομένου ότι η *printf* αρχίζει να διαβάζει από το τέλος της στοίβας η διαφορά ήταν 28 bytes άρα χρειαζόμασταν το *%7$s* (ή *%p%p%p%p%p%p%s*) αφού 7 * 4 bytes = 28. Τέλος, για να πάρουμε τον κωδικό γνωρίζοντας ότι το hash είναι *md5*  ψάξαμε σε μια τεράστια βάση με hashes στο internet όπως φαίνεται στο παρακάτω link *https://hashtoolkit.com/decrypt-hash/?hash=e5614e27f3c21283ad532a1d23b9e29d* και έτσι βρήκαμε τα στοιχεία εισόδου αντικρίζοντας ύστερα την χακαρισμένη σελίδα του "Plan X".

3) Πού βρίσκονται τα αρχεία του "Plan X";

 Στην χακαρισμένη σελίδα του "Plan X" είδαμε αρχικά ότι υπήρχε ένα πεδίο που ζητούσε κωδικό, ο οποίος κάθε φορά που στελνόταν με *POST* αίτηση στην σελίδα *ultimate.html* επιστρεφόταν ένα μήνυμα λάθους το οποίο έλεγε *Forbidden* πράγμα αρκετά λογικό αφού ο κωδικός ήταν άγνωστος. Αφού ανατρέξαμε στον κώδικα του *pico* προσέξαμε ότι το payload που στελνόταν με την *POST* αίτηση αντιγραφόταν σε έναν buffer ο οποιός αποθηκευόταν στην στοίβα και είχε μεταβλητό μέγεθος ανάλογα με το μέγεθος του payload το οποίο προερχόταν από το header *Content-Length* της αίτησης, στο οποίο προφανώς μπορούσαμε να του δώσουμε οποιαδήποτε τιμή θέλουμε. Άρα, η πρώτη σκέψη ήταν να βάλουμε για *Content-Length* μια τιμή μικρότερη του πραγματικού μεγέθους του payload ώστε να καταφέρουμε να κάνουμε με αυτόν τον τρόπο δικό μας buffer overflow και να πάρουμε πρόσβαση στα πραγματικά περιεχόμενα της *ultimate.html* χωρίς τον κωδικό. Οπότε, με λίγα λόγια ο κύριος στόχος ήταν να τρέξουμε τον κώδικα της συνάρτησης *serve_ultimate* και  οι δύο πιθανές επιλογές γι αυτό ήταν είτε να οδηγηθούμε μέσα στην ίδια την συνάρτηση και να διαχειριστούμε εμείς την προεργασία του stack frame της είτε στην κλήση της συνάρτησης από την συνάρτηση *post_param* που βρισκόμασταν (δηλαδή να μεταφέρουμε τον έλεγχο του προγράμματος στην εντολή που εκτελείται μετά την επιτυχή επαλήθευση του κωδικού). Για να το πετύχουμε πρακτικά αυτό έπρεπε να αντιμετωπίσουμε αρκετά εμπόδια που προέκυπταν από την ύπαρξη του *PIE* (*Position Independent Executable*) και των *canaries*. Έχοντας όμως στην διάθεση μας την *printf* που τύπωνε τα περιεχόμενα της στοίβας οι συνθήκες έγιναν πολύ πιο ευνοϊκές. Επιπλέον, ένα αρκετά ευνοϊκό ακόμα στοιχείο ήταν το σημείο στη συνάρτηση *post_param* όπου γινόταν η αντικατάσταση του ‘&’ και του ‘=’ σε ‘\0’ το οποίο το εκμεταλλευτήκαμε για να ξεπεράσουμε το εμπόδιο της συνάρτησης *strcpy* που είχε σκοπό την αντιγραφή του payload μας στον buffer και άρα όποτε χρειαζόμασταν το ‘\0’ (π.χ στα *canaries*) βάζαμε στο payload το ‘&’ (ascii κωδικός ‘26’) στην αντίστοιχη θέση. Εφόσον, λοιπόν, έγινε μια συνοπτική περιγραφή της ευπάθειας και των εμποδίων που ήρθαμε αντιμέτωποι μαζί με τις λύσεις τους αλλά και του στόχου που θέλαμε να πετύχουμε στην συνέχεια θα αναλυθεί βήμα - βήμα η επίθεση.
 
 Αρχικά, η πρώτη σημαντική παρατήρηση που έπρεπε να κάνουμε ήταν το σημείο που άρχιζε ο buffer όπου τελικά είδαμε πως βρισκόταν 72 θέσεις κάτω από τον *$ebp* (για *Content-Length* 0 που χρησιμοποιούσαμε). Όμως, επειδή ο buffer ήταν "δυναμικός" αποθηκευόταν και ένας δείκτης σε εκείνον 52 θέσεις πάνω από αυτόν (20 bytes κάτω από τον *$ebp*) οπότε για να βρούμε την διεύθυνση του ώστε να την τοποθετήσουμε σε εκείνο το σημείο του δείκτη (την διεύθυνση αυτή βέβαια την τοποθετούσαμε συνεχώς μέχρι και πριν την αρχή του *canary* για να είμαστε πιο σίγουροι) χρησιμοποιήσαμε το leak της *printf* στο 30ο byte (από το τέλος του stack frame της *check_auth*) το οποίο μας "πρόδιδε" μια διεύθυνση στο segment της στοίβας και πιο συγκεκριμένα τον *$ebp* της προηγούμενης συνάρτησης που καλούσε την *check_auth* (*saved $ebp*) δηλαδή της *route*, όπου υπολογίσαμε ότι βρισκόταν 232 bytes πάνω από την αρχή του buffer και άρα με αυτή την σχετική απόσταση προφανώς μπορούσαμε να ξέρουμε την αρχή του κάνοντας την αφαίρεση. Στην συνέχεια, δημιουργήσαμε ένα αντίγραφο του πραγματικού *canary*  το οποίο το γνωρίζαμε από το leak της *printf* στο 27ο byte (από το τέλος του stack frame της *check_auth*) αντικαθιστώντας το τελευταίο μηδενικό byte του με τον τρόπο που περιγράφηκε προηγουμένως δηλαδή με την τιμή ‘26’ (ascii κωδικός του ‘&’) και τέλος το τοποθετήσαμε στην σωστή θέση, η οποία ήταν 60 bytes πάνω από τον buffer (12 bytes κάτω από τον *$ebp*). Έπειτα, προσπαθήσαμε να μην πειράξουμε τα περιεχόμενα που αναφέρεται ο *$ebp* δηλαδή τον *$ebp* της συνάρτησης *route* (*saved $ebp*), όμως αυτό το γνωρίζαμε από το leak της *printf* στο 30ο byte που αναφέρθηκε και προηγουμένως. Το μόνο που έλειπε, ήταν να τοποθετήσουμε στην συνέχεια (4 bytes πάνω από τον *$ebp*) την δικιά μας διεύθυνση επιστροφής όπου τελικά πήραμε την απόφαση να εισάγουμε την διεύθυνση στον πραγματικό κώδικα της *serve_ultimate* η οποία βρισκόταν 2184 θέσεις* μετά την διεύθυνση επιστροφής της *check_auth* (*<route+114>*) την οποία την γνωρίζαμε από το leak της *printf* στο 31ο byte (από το τέλος του stack frame της *check_auth*). Τέλος, επειδή δεν επιλέξαμε την άλλη περίπτωση που καλείται πραγματικά η *serve_ultimate* και επιλέξαμε να διαχεριριστούμε εμείς το stack frame της έπρεπε να τοποθετήσουμε εμείς την διεύθυνση επιστροφής της (στο τέλος του payload δηλαδή 8 bytes πάνω απο τον *$ebp*) την οποία την βάλαμε να είναι ακριβώς στο τέλος της *route* (688 bytes μετά την *<route+114>*) ώστε να τερματίσει ομαλά η διεργασία που μας εξυπηρετεί (δηλαδή να γίνει το flush του *stdout* και να κλείσει και το socket).

*Κάνοντας δοκιμές τοπικά βγάζαμε άλλη απόσταση και δεν παίρναμε κάποιο αποτέλεσμα από τον server οπότε δοκιμάσαμε να το τρέξουμε σε vm της σχολής (μια και ο server τρέχει σε vm της σχολής) όπου τελικά πήραμε τη πραγματική απόσταση (πράγμα το οποίο μας “γλίτωσε” από ψάξιμο με brute force). Οπότε διαπιστώσαμε ότι οι αποστάσεις μεταξύ δύο σημείων σε δύο συναρτήσεις αλλάζουν από μηχάνημα σε μηχάνημα (οι απόστασεις μεταξύ δύο σημείων της ίδιας συνάρτησης είναι προφανώς οι ίδιες).

4) Ποια είναι τα results του "Plan Y";

Έχοντας τώρα πρόσβαση στην σελίδα που απαιτούσε κωδικό φανερώθηκε ότι το μυστικό μονοπάτι των αρχείων ήταν το */var/backup/* και πιθανώς για να μπορέσουμε να δούμε την λίστα των αρχείων δινόταν και ένα ακόμα αρχείο στο μονοπάτι αυτό το *backup.log*. Αρχικά, παρατηρώντας ότι το μονοπάτι αυτό δεν συμπεριλάμβανε τον κατάλογο *var/www/* ώστε να μπορέσουμε να έχουμε πρόσβαση μέσω του browser έπρεπε να βρούμε κάποιον άλλον τρόπο για να πάρουμε πρόσβαση σε οποιονδήποτε κατάλογο του server θέλαμε. Η πρώτη σκέψη ήταν να κάνουμε τον server να τρέξει ένα δικό μας *bash shell* κάνοντας ένα *ret2libc* (return-to-libc) attack αφού πρώτον δεν επιτρεπόταν η εκτέλεση κώδικα στην στοίβα (non executable stack) και δεύτερον είχαμε ήδη καταφέρει να εκτελέσουμε επιτυχώς το προηγούμενο buffer overflow attack μας. Όμως, σκεφτήκαμε ότι με το να τρέξουμε στον server ένα *bash shell* δεν θα καταφέρναμε κάτι ουσιαστικό εφόσον δεν θα είχαμε την δυνατότητα στην συνέχεια να εκτελέσουμε και άλλες δικές μας εντολές. Ύστερα, διαπιστώσαμε πως η μοναδική εντολή που έπρεπε να τρέξουμε ήταν κάποια εντολή που θα μας έδινε τα περιεχόμενα του αρχείου *backup.log* και μια τέτοια εντολή είναι η *cat*. Έτσι, ο μόνος μας στόχος ήταν να κάνουμε ένα *ret2libc* attack χρησιμοποιώντας την συνάρτηση *system* με όρισμα τη συμβολοσειρά *"cat  /var/backup/backup.log"* ώστε να καταφέρουμε να δούμε τα περιεχόμενα του αρχείου. Για να πετύχουμε το *ret2libc* attack θα έπρεπε τώρα να βάλουμε στη διεύθυνση επιστροφής την διεύθυνση της *system* και έναν δείκτη στην αρχή της συμβολοσειράς *"cat  /var/backup/backup.log"* ως όρισμα. Πιο συγκεκριμένα, έπρεπε να τοποθετήσουμε την διεύθυνση της *system* 4 bytes πάνω τον *$ebp*, να προσθέσουμε στην συνέχεια στα 8 bytes πάνω από τον *$ebp* την διεύθυνση στο τέλος της *route* όπως προηγουμένως (688 bytes μετά την *<route+114>*) ώστε να τερματίσει ομαλά η διεργασία που μας εξυπηρετεί μετά την εκτέλεση της *system* και τέλος στα 12 bytes πάνω από τον *$ebp* έπρεπε να βάλουμε τον δείκτη στην αρχή της συμβολοσειράς. Όμως, προέκυψαν δύο προβλήματα όπου το πρώτο ήταν το πού θα τοποθετούσαμε την συμβολοσειρά και το δεύτερο ήταν το πώς θα μαθαίναμε την διεύθυνση της *system*. Για το πρώτο αποφασίσαμε να τοποθετήσουμε την συμβολοσειρά ακριβώς πάνω από τον δείκτη της, 12 bytes πάνω από τον *$ebp* (δηλαδή στο τέλος), ώστε να είμαστε σίγουροι πώς δεν θα υπάρξει κάποια “επικάλυψη” στην συνέχεια δηλαδή μετά την κλήση της *system*. Έπειτα, υπολογίσαμε ότι η συμβολοσειρά άρχιζε 144 bytes κάτω από τον *$ebp* της *route* που κάνουμε leak μέσω της *printf* στο 30ο byte τοποθετώντας έτσι την τιμή αυτή στη θέση του δείκτη. Οπότε, για την ολοκλήρωση του attack το μόνο που έμενε ήταν να βρεθεί η διεύθυνση της *system*. Για να το πετύχουμε αυτό σκεφτήκαμε να κάνουμε leak κάποια “κοντινή” διεύθυνση στην *system* δηλαδή κάποια διεύθυνση που θα μας έδινε πληροφορία για το που βρίσκεται η *libc*. Μια διεύθυνση που γνωρίζουμε σίγουρα ότι βρίσκεται στην *libc* είναι η διεύθυνση επιστροφής της *main* (όπως είδαμε και στο μάθημα μέσα από την ερώτηση που αφορούσε για το ποιος καλεί την *main*) την οποία έπρεπε προφανώς να την βρούμε μέσω κάποιου leak. Για να βρούμε το σωστό offset που κάνει leak την διεύθυνση επιστροφής της *main* απενεργοποιήσαμε πρώτον τοπικά το *ASLR* και αφού είδαμε από τον *gdb* ότι είναι η *0xf7b2cee5* χρησιμοποιήσαμε το script *scan_and_find.py* για να βρούμε ποιό offset θα έπρεπε να βάλουμε στην *printf* ώστε να αντιστοιχεί στην διεύθυνση αυτή (μιας και δεν ήταν τόσο προφανές μέσω του *gdb*). Το offset αυτό ήταν τελικά ίσο με 111 δηλαδή η διεύθυνση επιστροφής της *main* απήχε 111 bytes από το τέλος του stack frame της *check_auth*. Αφαιρώντας, λοιπόν, την αρχή της *libc* (base address), την οποία την βρήκαμε μέσω του *gdb* και της εντολής *info proc mappings*, από την διεύθυνση αυτή που βρήκαμε παραπάνω μετρήσαμε την απόσταση μεταξύ αυτών των δύο η οποία θα φαινόταν χρήσιμη ώστε να βρούμε το base address της *libc* στον server όπου εκεί δεν έχουμε την δυνατότητα να το μάθουμε από τον *gdb*. Με αντίστοιχο τρόπο βρήκαμε τοπικά την απόσταση της *system* από το base address της *libc*. Συνοψίζοντας, για να βρούμε την πραγματική διεύθυνση της *system* έπρεπε πρώτα να γίνει leak η διεύθυνση επιστροφής της *main*, μετά να αφαιρέσουμε από εκείνη τη πρώτη απόσταση που υπολογίσαμε για να βρούμε την αρχή της *libc* και τέλος να προσθέσουμε στην αρχή της *libc* την δεύτερη απόσταση για να βρούμε τη πραγματική διεύθυνση της *system*\*. Έχοντας και την διεύθυνση της *system* μπορέσαμε τελικά να ολοκληρώσουμε το attack όπου βρήκαμε και τα υπόλοιπα αρχεία τα οποία τα διαβάσαμε με παρόμοιο τρόπο αλλάζοντας το μονοπάτι στην *cat* και έτσι καταφέραμε να βρούμε τελικά την απάντηση στο *z.log*.
	
\*Αξίζει να σημειωθεί πως και σε αυτήν την περίπτωση οι υπολογισμοί των αποστάσεων για την εύρεση της διεύθυνσης της *system* διέφεραν στα δικά μας μηχανήματα, πιθανώς για τον ίδιο λόγο με παραπάνω, όμως η συνολική απόκλιση δεν ήταν αρκετά μεγάλη. Πιο συγκεκριμένα, η απευθείας απόσταση της *system* από την διεύθυνση επιστροφής της *main* στον server ήταν ίση με 148415 ενώ στα μηχανήματα μας ήταν ίση με 158027 οπότε δεν είχε κάποιο νόημα που βρίσκαμε την συνολική απόσταση αυτή μέσω του base address της *libc* και όχι απευθείας (πιστεύαμε ότι με αυτόν τον τρόπο θα είχαμε μεγαλύτερη ακρίβεια). Οπότε δοκιμάσαμε όπως και προηγουμένως να υπολογίσουμε τις αποστάσεις στα vm της σχολής, το οποίο μας "γλίτωσε" πάλι από κάποιο πιθανό brute force γύρω από την τιμή 158027 για να βρούμε την διεύθυνση της *system* (δηλαδή θα μπορούσαμε να κάνουμε brute force σε κάποιο μικρό σχετικά διάστημα π.χ στο [138000 - 178000] μιας και οι αποκλίσεις μεταξύ των μηχανημάτων δεν είναι τεράστιες).

5) Ποιο είναι το code του "Plan Z";

Εκτός από την απάντηση για το προηγούμενο ερώτημα το *z.log* αρχείο περιείχε και κάποια στοιχεία που αφορούσαν το "Plan Z". Το πρώτο ενδιαφέρον στοιχείο ήταν η αρίθμηση κάποιων περίεργων λέξεων που θα μπορούσε κανείς να πει πως έμοιαζαν με συντεταγμένες. Αναζητώντας αυτό το pattern στο internet βρήκαμε ότι αντιστοιχούσε στο τελευταίο παιχνίδι σκάκι μεταξύ του Deep Blue και του Kasparov με την μόνη διαφορά ότι δεν υπήρχε η τελευταία κίνηση η οποία ήταν η *c4*. Δεδομένου ότι για να βρούμε τον κωδικό του "Plan Z" χρειαζόταν η κίνηση αυτή το μόνο που έλλειπε ήταν η *public IP* διεύθυνση του μηχανήματος. Ψάχνοντας για το πως θα βρούμε την *public IP* διεύθυνση των δικών μας μηχανημάτων διαπιστώσαμε πως αυτό μπορεί να γίνει κάνοντας κάποια αίτηση σε κάποιον online server (π.χ  *ifconfig.me*) που μας επιστρέφει την *public IP* διεύθυνση (πράγμα λογικό αφού τα πακέτα περιλαμβάνουν την *public IP* διεύθυνση). Οπότε το μόνο που έπρεπε να κάνουμε ήταν να αναγκάσουμε τον server να κάνει αίτηση σε κάποιον από αυτούς τους online servers και τελικά αυτό που κάναμε ήταν να βάλουμε ως όρισμα στην *system* την συμβολοσειρά *"curl ifconfig.me"* όπου και μας επέστρεψε, με τον ίδιο τρόπο με πριν, το αποτέλεσμα δηλαδή την *public IP* διεύθυνση. Τέλος, συννενώσαμε την παραπάνω κίνηση *c4* με την *public IP* του μηχανήματος και βρήκαμε τον κωδικό του "Plan Z".





#### Γενικές παρατηρήσεις για τα ερωτήματα 3-5 :

* Το bash script *run.sh* εκτελεί το python script payloads.py το οποίο εκτελεί με την σειρά του με αυτοματοποιημένο τρόπο τα ερωτήματα. Επειδή δεν είναι σίγουρο ότι πάντα θα έρθει απάντηση (π.χ μπορεί η διεύθυνση του buffer να περιέχει το μηδενικό byte οπότε δεν θα πετύχει το buffer overflow λόγω της strcpy) τόσο το bash script όσο και το python script εκτελούν κώδικα σε loops μέχρι να βρεθούν οι απαντήσεις.
* Όλες οι μετρήσεις που αναφέρθηκαν προηγουμένως έγιναν μέσω *gdb*.
* Όσον αφορά τις σχετικές αποστάσεις (από τον $ebp, από τον buffer ...) χρησιμοποιούμε τις έννοιες "πάνω"/"μετά" και "κάτω"/"πριν" οι οποίες είναι ισοδύναμες με πρόσθεση(+) και αφαίρεση(-) αντίστοιχα.
* Το *Content-Length* το θέσαμε σε 0 για να αποφύγουμε περιπτώσεις στο πρόγραμμα που θα οδηγούσαν σε κάποιο segmentation fault (crash).
* Επειδή σε κάποια σημεία του payload έπρεπε να υπάρχει κάποιο padding ώστε να ταιριάξουν οι θέσεις προσθέσαμε κάποια bytes με τιμή 'ff'.
* Τα bytes για κάθε λέξη στο payload έπρεπε να αντιστραφούν για να γράψουμε την σωστή τιμή.
* Για τα leaks της *printf* κάναμε *GET* αιτήσεις όπως στο ερώτημα 2 δηλαδή χωρίς το *Αuthorization* header.
* Όλες οι αιτήσεις στον remote server έγιναν με την χρήση της *curl* και του πρωτοκόλλου *SOCKS5*.





